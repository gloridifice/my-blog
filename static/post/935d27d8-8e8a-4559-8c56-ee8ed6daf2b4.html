<!DOCTYPE html><html>
  <head lang="zh_CN">
    <meta http-equiv="Content-Type" content="charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/assets/js/header.js"></script>
    <link rel="stylesheet" href="/assets/css/reset.css">
    <link rel="stylesheet" href="/assets/css/root.css">
    <link rel="stylesheet" href="/assets/css/color_scheme_v2.dark_mode.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;600;700&amp;display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/layout.css">
    <link rel="stylesheet" href="/assets/css/post.css">
    <link rel="stylesheet" href="/assets/css/color_scheme_v2.dark_mode.css">
    <title>🦆 游戏开发中的编程理论基础</title>
  </head>
  <body>
    <div class="post">
      <div class="catalogue">
        <div>
          <ul>
            <li class="h1"><a href="#heading1_0">
                <t>基础知识</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t>编程范式</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t>走近面向对象编程，之前</t>
              </a></li>
            <li class="h1"><a href="#heading1_1">
                <t>什么是面向对象 OOP</t>
              </a></li>
            <li class="h1"><a href="#heading1_2">
                <t>用继承模型实现游戏</t>
              </a></li>
            <li class="h1"><a href="#heading1_3">
                <t>组合模型大于继承模型</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t>组合模型和继承并不冲突</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t>容易接触到的组合模型</t>
              </a></li>
            <li class="h1"><a href="#heading1_4">
                <t>面向对象在游戏开发中的问题</t>
              </a></li>
            <li class="h1"><a href="#heading1_5">
                <t>什么是数据驱动 Data-Driven</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t>在开始介绍新范式之前</t>
              </a></li>
            <li class="h2"><a href="#heading2_0">
                <t>从数据开始</t>
              </a></li>
            <li class="h1"><a href="#heading1_6">
                <t>什么是 ECS</t>
              </a></li>
          </ul>
        </div>
      </div>
      <div class="navi"><a href="/home.html">Home</a><a href="https://gloridifice.notion.site/3659ec2ee2f7498ab744662c364b518a?v=0d711eab95f748eb82a966726ec3f757&amp;pvs=4">Notes</a></div>
      <div class="sidebar_wrapper_left sidebar_wrapper"></div>
      <div class="sidebar_wrapper_right sidebar_wrapper"></div>
      <div class="contents">
        <div class="page_description">
          <h1 class="title">🦆 游戏开发中的编程理论基础</h1>
          <div class="sub_info">
            <p class="date">2024-04-06</p>
            <div class="type_tags">
              <p class="tag">Game Dev</p>
              <p class="type">Dev</p>
            </div>
          </div>
        </div>
        <div class="page_contents">
          <div class="callout">
            <div class="icon">💡</div>
            <div class="text">
              <t>前沿：本篇文章为社团分享，作者为宏楼(我) (Koiro) 和 </t>
              <t class="href" onclick="window.open('https://github.com/raspirin')">拉斯普（Aspirin）</t>
              <t>两人。本文包含游戏开发中一些重要理论的基本概念，包括编程范式、面向对象、组合与继承、面向数据、ECS 的概念和优点以及一些现在市面上游戏引擎的使用的架构。</t>
            </div>
          </div>
          <p></p>
          <h1 id="heading1_0">
            <t>基础知识</t>
          </h1>
          <h2 id="heading2_0">
            <t>编程范式</t>
          </h2>
          <p>
            <t>让我们从简单一点的内容开始。程序语言不仅仅给我们提供了强大的工具，还帮助我们组织我们关于一件事情“如何做”的想法。为此，程序语言需要赋予我们三种能力：表达最基本的表达式的能力，它们组成了这个程序语言最基本的概念，例如整数、浮点数等基本数据类型（以及锁、通道等等）；组合的能力，我们需要把最基本的内容组合起来构建复杂的东西；抽象的能力，就是把组合起来的复杂结构当作一个整体并赋予名字的能力。</t>
          </p>
          <p>
            <t>基本数据类型大家都了解，我们具体介绍一下组合的能力和数据的能力。例如现在我们现在要表示一个三维空间中的一个点，我们可以用三个数例如 x y z 来表示。但是这样我们每声明一个点，就需要三个变量，同时我们需要用命名的方式给不同的点的 x y z 区分开来。下面就是声明两个点的例子。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c</div>
              <div class="code_part_text">
                <t>int main(){
  //第一个点
  float x1 = 2.0f;
  float y1 = 3.0f;
  float z1 = 0.1f;
  //第二个点
  float x2 = 1.0f;
  float y2 = 2.0f;
  float z2 = 0.6f;
}</t>
              </div>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t>一方面，我们要用命名的方式来声明每个变量的关联性，另一方面，声明多个变量让我们的代码变得很难管理，例如如果我们声明三个点，就需要声明九个变量。可见这样表达非常麻烦。</t>
          </p>
          <p>
            <t>于是我们想，能不能将有关联的对象组合在一起，同时把它赋予一个新的名字呢？C 语言赋予了我们这样的能力，这个能力也就是 C 语言中的 </t>
            <t class="code">struct</t>
            <t>（结构体）。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c</div>
              <div class="code_part_text">
                <t>struct Vector3 {
  float x;
  float y;
  float z;
};</t>
              </div>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t>这里我们把三个数据类型组合成了一个新的数据类型，并给它起名为 </t>
            <t class="code">Vector3</t>
            <t>（三维向量）。这就是程序语言赋予我们组合和抽象能力的体现之一。我们把 x y z 组合在了一起，并抽象成了 </t>
            <t class="code">Vector3</t>
            <t>.</t>
          </p>
          <p>
            <t>我们通过程序语言提供的这些能力构建我们想要的程序，程序语言也反过来通过它们塑造我们解决问题的风格。这类风格一般被称作编程范式。能叫得出名字的编程范式有很多，比如指令式编程、面向过程编程、面向对象编程、函数式编程之类的。值得注意的是，不同的编程范式不应该被看作是彼此独立甚至对立的，但有些编程范式确实会产生冲突，这点我们后面聊面向数据编程的时候会接着讲。</t>
          </p>
          <h2 id="heading2_1">
            <t>走近面向对象编程，之前</t>
          </h2>
          <blockquote>
            <t>在本文中，“对数据的操作”、“操作”和“函数”的含义差不多，在本模块的语境中请当作一个概念看待。</t>
          </blockquote>
          <p>
            <t>回忆一下我们从 C 语言课上学到的东西，C 语言允许使用我们使用基本类型的变量来存放我们想要的数据，这是它赋予我们的第一个能力。同时，它也允许我们通过语句来操作这些变量，我们还可以把多条语句放在一个函数里面，这样我们就能把一个复杂的操作当作一个操作看待，这也是 C 语言赋予我们组合和抽象能力的体现之一。</t>
          </p>
          <p>
            <t>C 风格（准确地说是面向过程）的编程范式将程序的重心放在函数上，也就是我们程序要完成的操作上。在这种观点下， 程序实际上是一系列的函数声明，我们把我们会用到的操作全都以函数的形式写下来，而变量是函数之间传递信息的方法。这种方法在维护某些大型项目的时候会遇到一些很特别的问题：首先是执行流过长会导致程序的运行难以分析和排障，虽然我们写代码的时候能够将程序的执行流看作一个不可分割的整体，但是我们在调试的时候仍就得将它们展开。其次是变量和关于它们的操作在代码逻辑上没有关联性，这会带来很多困惑。举例子来说：左偏树和二叉搜索树都被存储成数组（大家不需要知道这两个东西是什么，只要知道它们是数组就可以），而它们的区别仅在于对数组的操作不同。比如它们的插入函数就彼此不同。这种情况下，如果我们不用名称或者注释等方法注明，我们不知道一个数组是左偏树还是二叉搜索树。因此我们会说这两个数据结构和维护它们的操作在代码逻辑上没有关联性，但其在数据结构的逻辑上是有关联性的。因此我们需要一种将数据和对数据的操作的关联性表达在代码中的能力。也就是将数据和对数据的操作组合和抽象起来的能力。</t>
          </p>
          <h1 id="heading1_1">
            <t>什么是面向对象 OOP</t>
          </h1>
          <p>
            <t></t>
            <t> </t>
          </p>
          <p>
            <t>来看看面向对象的编程范式对上述的问题做出了什么解决的尝试。面向对象的编程范式把编程从一系列函数声明变成了一系列对象（更准确地说，是类）的声明。它认为应当把对象看作是程序执行功能的基本单位，或者说，对象是工厂里的工人，而功能是工人要做的事情。面向对象的编程范式是怎么实现这个黑魔法的呢？大部分面向对象的程序语言构造变量和表达式的方式跟我们在 C 语言里习惯的并不不同，那我们得思考以下面向对象的程序语言给我们提供的组合和抽象的能力有什么不同了。</t>
          </p>
          <p>
            <t>一部分的面向对象的程序语言会提供一个叫做“类”（class）的基本概念，这是一种组合基本单元的方式。不过不同于我们在 C 语言的结构体里面做的那样，类不仅仅能组合数据，还可以把操作也一起组合进来。下面是一个类的示例。这里的 </t>
            <t class="code">public</t>
            <t> 关键字大家先忽略，我们下面会介绍。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c#</div>
              <div class="code_part_text">
                <t>public class Vector3 {
  //成员字段
  public float x;
  public float y;
  public float z;

  //成员方法
  public void Clear() {
    x = 0f;
    y = 0f;
    z = 0f;
  } 
}</t>
              </div>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t>在类的语境里，类包括两部分：第一部分是类的成员字段，也就是持有的变量，比如上面的 x y z；第二部分是类的成员方法，也就是类持有的函数，比如上面的 </t>
            <t class="code">Clear()</t>
            <t>，这个函数没有什么特别的作用，就只是把这个向量的 x y z 都设置成 0。成员字段是这个类应当存储的数据，而成员方法就是对这些数据可行的操作。</t>
          </p>
          <p>
            <t>在这个示例中，我们声明了一个叫 </t>
            <t class="code">Vector3</t>
            <t> 的类，同时我们将一个操作也放了进来也就是 </t>
            <t class="code">Clear</t>
            <t> 函数，或者说 </t>
            <t class="code">Clear</t>
            <t> 方法。方法与函数的不同在于在方法中，我们天然地可以访问类中的其它变量，我们看到，上面的 </t>
            <t class="code">Clear</t>
            <t> 方法可以直接访问 x y z 变量，而不需要把他们当作参数传进来。我们的 </t>
            <t class="code">Clear</t>
            <t> 方法实际上类似于下面这样一个函数，这个函数在类之外。下面的函数中，我们传了一个名字为 </t>
            <t class="code">self</t>
            <t> 的 </t>
            <t class="code">Vector3</t>
            <t>；而在上面的类的函数中我们并不需要传一个 </t>
            <t class="code">self</t>
            <t> 进去，实际上我们把这个 </t>
            <t class="code">self</t>
            <t> 隐藏了，我们隐藏地认为类中的函数可以使用这个类中的其它变量，所以我们并不用写出这个 </t>
            <t class="code">self</t>
            <t>. 我们把这样的函数称作方法。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">c#</div>
              <div class="code_part_text">
                <t>void Clear(Vector3 self) {
  self.x = 0f;
  self.y = 0f;
  self.z = 0f;
}</t>
              </div>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t>同时，优秀的面向对象的程序要求每个类设计得足够小，小到只能完成一个逻辑上的功能。</t>
          </p>
          <p>
            <t>这是一种理解组合和抽象的新方式，在类的范畴下，我们要思考的内容不再是整个程序在什么情况下要做什么，而是这些类应当具备什么功能，为了让某个类具备某个功能，我们应当在其中存储什么数据，实现什么方法。</t>
          </p>
          <p>
            <t>另外，面向对象的编程范式认为，过多地考虑外部代码的正确性并不是好事，所以它希望程序员能够放弃做这件事情。因此，在定义类的时候，我们可以只让外部看到我们希望让别的类知道的细节，比如我们可以只对外表明我们有 A 方法和 B 方法，而除了 A 和 B 方法外我们内部还有一些其他的方法。这种技术被称为封装。</t>
          </p>
          <p>
            <t>回到上面的代码，我们发现每个变量和类的声明前都有一个 </t>
            <t class="code">public</t>
            <t> 关键字，这个关键字其实就是声明整个类和变量是对其它类都可见的。如果我们不声明，在很多编程语言中，这个字段默认对其它类是不可见（也就是说，字段默认是 </t>
            <t class="code">private</t>
            <t> 的）。</t>
          </p>
          <p>
            <t>那么，依靠类，我们是怎么解决先前的那些问题的呢。我们先回顾一下之前的问题是什么。</t>
          </p>
          <ul>
            <li>
              <t>执行流过长会导致程序的运行难以分析和排障</t>
              <div class="image_wrapper"><img src="/post/935d27d8-8e8a-4559-8c56-ee8ed6daf2b4/img_eb9d4225-a075-4b57-a68e-d0364370ea89.gif">
                <div class="caption">
                  <t class="href" onclick="window.open('https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/fork.c?h=v6.7-rc4')">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/fork.c?h=v6.7-rc4</t>
                  <t>  fork.c 中的长代码</t>
                </div>
              </div>
            </li>
          </ul>
          <ul>
            <li>
              <t>变量和关于它们的操作在代码逻辑上没有关联性</t>
            </li>
          </ul>
          <p>
            <t>首先，我们规定了类的功能之后，在封装的帮助下，就只需要考虑这个功能本身的正确性，如果一个类本身工作正常，那么它在与别的类合作的时候也一定工作正常。因为我们只需要把一个类中承诺能实现的功能的部分暴露给其他人，其它部分被限制在类内部。其次，在封装的帮助下，我们不能也不会过分地考虑程序的细节，因为别的库的大部分代码都被其它开发者隐藏了。这两点把我们思考中要容纳的范畴缩小到了一个相对轻松的范畴。面向对象范式的支持者认为，应用面向对象的思想去设计程序会让程序变得更好维护。</t>
          </p>
          <p>
            <t>我们以 Minecraft 的方块 </t>
            <t class="code">Block</t>
            <t> 为例，给大家具体介绍一下类的概念。之前我们介绍了类，它拥有组合变量和操作的能力。MC 中方块的类简化后是代码中这样的。为了方便大家阅读，在后面我们所有的 </t>
            <t class="code">public</t>
            <t> 关键字都省略掉，大家认为所有的字段都是 </t>
            <t class="code">public</t>
            <t> 就好了。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">java</div>
              <div class="code_part_text">
                <t>class Block {
  String name;
  float explosionResistance; //爆炸抵挡能力
  float destroyTime; //破坏这个方块需要的时间
  Item item;
  ...
}</t>
              </div>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t>我们在 </t>
            <t class="code">Block</t>
            <t> 类中声明了许多所有方块几乎都会有的信息，例如破坏需要的时间等等。这时，要创建一个方块，例如泥土，我们只需要把 </t>
            <t class="code">Block</t>
            <t> 类实例化出来就好了。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">java</div>
              <div class="code_part_text">
                <t>Block dirt = new Block(&quot;dirt&quot;,...);</t>
              </div>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t>等下，什么是实例化？我们之前介绍了 </t>
            <t class="code">struct</t>
            <t> ，我们创建一个 </t>
            <t class="code">struct</t>
            <t> 时就是同时创建了其中所有的声明的变量，这些变量被“打包”到一个变量里。几乎一样的，我们创建一个类的时候，其实就是同时将一堆类中声明过的变量和函数创建出来，“打包”在一个变量里，我们把这个变量称作“对象”，我们称这个过程为“实例化”。这个被创建出的 </t>
            <t class="code">dirt</t>
            <t> 变量就是被我们称作的“对象”。各位可能好奇我们没有设置过这些变量的初始值，那我们创建出的泥土里的变量的初始值是什么呢，在编程语言中我们有很多声明和设置对象的初始值的方法，大家可以在学编程语言时了解。这里我们方便大家理解概念，把这些代码省略了，这样看起来会更好懂一点。</t>
          </p>
          <p>
            <t>好了，现在我们创建了一个泥土方块，我们可以类似地创建石头方块、树叶方块等等。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">java</div>
              <div class="code_part_text">
                <t>Block dirt = new Block(&quot;dirt&quot;,...);
Block stone = new Block(&quot;stone&quot;,...);
Block leaf = new Block(&quot;leaf&quot;,...);
...</t>
              </div>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t>大家注意我们上面代码里的括号，这是我们在 Java 语言设置对象初始值的一种方式。我们不同的方块有不同贴图、名字、破坏时间，都可以在我们声明这个方块的括号中设置。</t>
          </p>
          <p>
            <t>我们刚刚举例介绍了类是如何组合变量的，现在我们来看看“操作(函数/方法)”，举个例子，我们每个方块都会有在被破坏时掉落物品的行为，我们在 Block 类里写了一个 </t>
            <t class="code">spawnDrops</t>
            <t> （生成掉落物）方法，在方块被破坏时生成我们的掉落物。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">java</div>
              <div class="code_part_text">
                <t>//Block class  
void spawnDrops(){

}</t>
              </div>
            </div>
            <div class="caption"></div>
          </div>
          <div class="column_list">
            <div class="column">
              <p>
                <t>但是在 Minecraft 中，不同的方块掉落物品的行为是不同的，比如泥土是掉落自己的方块物品，树叶是概率掉落树苗。但是我们 </t>
                <t class="code">Block</t>
                <t> 类只有一个，只能实现一种逻辑。实际上，不止掉落物品，我们每个方块的各种行为都是不同的，那么有没有一种既可以保持它们有相同的行为声明和变量声明，又能实现每个方块特别行为的架构呢？</t>
              </p>
            </div>
            <div class="column">
              <div class="image_wrapper"><img src="/post/935d27d8-8e8a-4559-8c56-ee8ed6daf2b4/img_f10b4c7a-5325-45d8-87d1-022652a1945c.png">
                <div class="caption"></div>
              </div>
            </div>
          </div>
          <p>
            <t>继承这个概念出现了。它允许我们在给我们的类扩充新功能的同时，保留旧的那一个类的内容。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">java</div>
              <div class="code_part_text">
                <t>class LeafBlock extends Block {
  void spawnDrops() {
    //有概率掉落树苗的逻辑
  }
}</t>
              </div>
            </div>
            <div class="caption"></div>
          </div>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">java</div>
              <div class="code_part_text">
                <t>class DirtBlock extends Block {
  void spawnDrops() {
    //掉落方块物品的逻辑
  }
}</t>
              </div>
            </div>
            <div class="caption"></div>
          </div>
          <p>
            <t>上面我们从 </t>
            <t class="code">Block</t>
            <t> 派生了两个新的类，两个类继承自 </t>
            <t class="code">Block</t>
            <t>，它们拥有 </t>
            <t class="code">Block</t>
            <t> 类的内容，同时类允许我们修改其中某个方法的逻辑。这就解决了我们之前的遇到的问题。</t>
          </p>
          <h1 id="heading1_2">
            <t>用继承模型实现游戏</t>
          </h1>
          <p>
            <t></t>
            <t> </t>
          </p>
          <p>
            <t>我们刚刚了解过了继承，用继承去设计游戏是一件符合直觉的事情。以 Minecraft 为例，Minecraft 是一个使用继承模型实现的游戏。在 Minecraft 中，我们用实体 Entity 这个基类来实现各种不是方块的物体，例如掉落物、生物等。我们看看 Minecraft 是怎么实现鸡和牛的，因为所有生物是有共性的，例如生物有血量系统、会受伤，于是开发者派生出 LivingEntity 这个类作为所有生物的基类。每个生物的行为是不一样的，因此开发者要派生出每个具体生物的类。</t>
          </p>
          <p>
            <t>例如：只有鸡在空中会缓慢降落，因此开发者只需把缓落逻辑写在 Chicken 类中。类似的，开发者把用桶接牛奶的逻辑写在 Cow 类中。</t>
          </p>
          <div class="column_list">
            <div class="column">
              <div class="image_wrapper"><img src="/post/935d27d8-8e8a-4559-8c56-ee8ed6daf2b4/img_e569b01b-bd86-4d05-af96-7e30bd5171e0.gif">
                <div class="caption"></div>
              </div>
            </div>
            <div class="column">
              <div class="image_wrapper"><img src="/post/935d27d8-8e8a-4559-8c56-ee8ed6daf2b4/img_d8c270e6-1fb8-4a26-a78e-0f4ba1a4c35c.gif">
                <div class="caption"></div>
              </div>
            </div>
          </div>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">java</div>
              <div class="code_part_text">
                <t>public void aiStep() {
      super.aiStep();
      this.oFlap = this.flap;
      this.oFlapSpeed = this.flapSpeed;
      this.flapSpeed += (this.onGround() ? -1.0F : 4.0F) * 0.3F;
      this.flapSpeed = Mth.clamp(this.flapSpeed, 0.0F, 1.0F);
      if (!this.onGround() &amp;&amp; this.flapping &lt; 1.0F) {
         this.flapping = 1.0F;
      }

      this.flapping *= 0.9F;
      Vec3 vec3 = this.getDeltaMovement();
      if (!this.onGround() &amp;&amp; vec3.y &lt; 0.0D) {
         this.setDeltaMovement(vec3.multiply(1.0D, 0.6D, 1.0D));
      }

      this.flap += this.flapping * 2.0F;
      if (!this.level().isClientSide &amp;&amp; this.isAlive() &amp;&amp; !this.isBaby() &amp;&amp; !this.isChickenJockey() &amp;&amp; --this.eggTime &lt;= 0) {
         this.playSound(SoundEvents.CHICKEN_EGG, 1.0F, (this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.0F);
         this.spawnAtLocation(Items.EGG);
         this.gameEvent(GameEvent.ENTITY_PLACE);
         this.eggTime = this.random.nextInt(6000) + 6000;
      }
   }</t>
              </div>
            </div>
            <div class="caption">
              <t>鸡的滑翔逻辑（氛围代码，不需要看懂）</t>
            </div>
          </div>
          <div class="column_list">
            <div class="column">
              <p>
                <t>在继承结构中，Chicken 和 Cow 都继承自 Animal 类，而 Animal 则经过多层继承来自 LivingEntity。</t>
              </p>
              <p></p>
            </div>
            <div class="column">
              <div class="image_wrapper"><img src="/post/935d27d8-8e8a-4559-8c56-ee8ed6daf2b4/img_74b24b3c-981b-4886-b37c-3b2d971c46ee.png">
                <div class="caption">
                  <t>牛 Cow 类的继承关系</t>
                </div>
              </div>
            </div>
          </div>
          <p>
            <t>但是各位思考一个问题，如果我们要做一只既可以接奶又可以缓落的生物，我们该怎么做？</t>
          </p>
          <p>
            <t>这个问题在现实中很好解决，既然我们无法同时继承鸡的类或者牛的类，那我们创造一个新类，把鸡的滑翔逻辑和牛的接奶逻辑都放进去就好了。但各位应该发现一些问题了：我们复制了代码。复制代码是个很棘手的问题，因为在未来我们修改一个代码时要把所有的复制代码也都改了，这降低了代码的可维护性。在继承模型中，为了缓解复制代码的问题，我们只能将各种行为抽象成很更多类。例如我们看牛的类的继承关系：从 Animal 到 Mob 中有很多层类。但如果我们想到一个生物不能兼容现有的任何类，那么我们又要重新调整继承关系，或者选择复制之前的代码，造成代码复制的问题。如果我们能预知未来，我们就够构造一个完美的继承结构；但现实是我们不能，我们要么在每次遇到新需求的时候重整继承结构，要么就复制代码。</t>
          </p>
          <div class="image_wrapper"><img src="/post/935d27d8-8e8a-4559-8c56-ee8ed6daf2b4/img_42ec6951-0feb-4a94-b98c-3d4e962e4758.png">
            <div class="caption"></div>
          </div>
          <p>
            <t>所以，在继承模型中，我们很难把不同的功能组合在一起。</t>
          </p>
          <h1 id="heading1_3">
            <t>组合模型大于继承模型</t>
          </h1>
          <p>
            <t>于是人们实践出了组合模型。</t>
          </p>
          <p>
            <t>设想一下如果我们把物体的功能都分散成每一个能力会怎样。对于一只鸡来说，我们可以这样拆分它的行为（需要怎样的能力）：</t>
          </p>
          <ul>
            <li>
              <t>生命能力</t>
            </li>
          </ul>
          <ul>
            <li>
              <t>Ai 能力</t>
            </li>
          </ul>
          <ul>
            <li>
              <t>走路能力</t>
            </li>
          </ul>
          <ul>
            <li>
              <t>缓落能力</t>
            </li>
          </ul>
          <ul>
            <li>
              <t>接受药水效果能力</t>
            </li>
          </ul>
          <ul>
            <li>
              <t>……</t>
            </li>
          </ul>
          <p>
            <t>类似的，对于牛，我们完全可以写一个“产奶能力”；这样先前那个生物的问题就很好解决了，我们只要把“缓落能力”和“产奶能力”组合在一起，都给一个生物就可以了。组合还有很多其它好处，假如我们要写攻击逻辑，我们不用在乎这个物体是什么，只要其存在生命能力，那我们就执行生命能力的受伤逻辑。更简单的，如果一个物体没有生命能力，那它就是无法受伤的物体；没有接受药水效果能力，就是免疫药水效果的物体，因为药水效果不会对其执行。</t>
          </p>
          <h2 id="heading2_2">
            <t>组合模型和继承并不冲突</t>
          </h2>
          <p>
            <t>继承是编程语言的特性，它和组合模型并不冲突。例如：不同生物的 AI 行为是不同的，但是他们有共享的部分，因此它们可以从同一个基类中派生出来。</t>
          </p>
          <p></p>
          <h2 id="heading2_3">
            <t>容易接触到的组合模型</t>
          </h2>
          <p>
            <t>现代游戏引擎几乎都是可以使用组合模型的。在 Unity 中，每个物体的行为由各种各样的组件实现的。在 Godot 中，我们可以用 Node 来实现组合。</t>
          </p>
          <div class="column_list">
            <div class="column">
              <div class="image_wrapper"><img src="/post/935d27d8-8e8a-4559-8c56-ee8ed6daf2b4/img_2a79f15f-1a99-431f-9c9a-9a116c7c9c2a.png">
                <div class="caption">
                  <t>Unity</t>
                </div>
              </div>
            </div>
            <div class="column">
              <div class="image_wrapper"><img src="/post/935d27d8-8e8a-4559-8c56-ee8ed6daf2b4/img_f6ff5544-ef3b-40dc-be8e-78e1aaf752c9.png">
                <div class="caption">
                  <t>Godot</t>
                </div>
              </div>
            </div>
          </div>
          <p></p>
          <h1 id="heading1_4">
            <t>面向对象在游戏开发中的问题</t>
          </h1>
          <p>
            <t></t>
            <t> </t>
          </p>
          <p>
            <t>软件工程里有一句经典的名言：没有银弹，亦即没有通用的解决方案。</t>
          </p>
          <p>
            <t>面向对象在实际的工程实践中同样有很多的问题。首先是性能问题，这主要体现在两个方面：其一是我们在通过类获得我们想要的功能时，一定也不必要地获得了我们不需要的功能，而所有的这些功能都是有开销的；其二是“对象”这个概念对现在的机器并不友好，设想这么一个场景，我们需要获得大量对象的名字，但是为了它们的名字，我们需要将所有的对象都拉进我们的内存中，这通常包括我们在对象里存储所有其它数据。很快，内存里就会充满了我们不需要的数据。</t>
          </p>
          <p>
            <t>实际上，这些数据并没有跟看起来的那样与我们要解决的问题无关，我们实际上将一个具有无法管理的内部状态带进了我们的上下文。我们无法得知某些操作是否跟它承诺的那样无害，因为我们看不到封装的另一头，直到某天一个神秘的内部错误毁了我们写的整段代码。</t>
          </p>
          <p>
            <t>另一个问题与面向对象的思想有关，它总是鼓励程序员构造复杂的封装。类强大的功能总让程序员误以为所有的问题都可以通过构造一个新类来解决。出现新问题？实现新功能？没关系，我们都可以通过构造一个新的类来解决。于是我们将越来越多的类组合成新类，把这个不可控的内部状态变得越来越大，最后我们会为了实现一个简单的功能而写出一大堆没有必要的样板代码。</t>
          </p>
          <p>
            <t>看起来面向对象的范式远远没有它看起来那么清爽无害，有没有能够解决这个问题的方法呢？</t>
          </p>
          <h1 id="heading1_5">
            <t>什么是数据驱动 Data-Driven</t>
          </h1>
          <p>
            <t></t>
            <t> </t>
          </p>
          <blockquote>
            <t>在下面的文章中 “数据驱动” 和 “面向数据” 表示同一个意思，当你看到其中的一个时，请将其换成你喜欢的那一个名词；</t>
          </blockquote>
          <h2 id="heading2_4">
            <t>在开始介绍新范式之前</t>
          </h2>
          <p>
            <t>我们要再一次地指出：没有通用的解决方案，同时不同的编程范式也并不是互斥的。我们应当做的是在一个编程范式擅长的地方去发挥这个范式的长处，而不是固执地认为某个范式能解决所有的问题。</t>
          </p>
          <h2 id="heading2_5">
            <t>从数据开始</t>
          </h2>
          <p>
            <t>数据驱动的编程依赖与数据的模式，根据不同的模式执行不同的行为。这是一个很简单也很难的描述，它并不能像面向对象那样把程序描述成一个我们都能以直觉去理解的样子。要理解数据的模式，我们先要理解什么是相似的数据。</t>
          </p>
          <p>
            <t>很多时候，其实我们并不是非常关心我们的数据到底是什么，我们其实只关心数据能完成的事情。比如，我们对一组数据做排序时，我们只关心这组数据之间是不是能排序，并不关心他们是否可加、可复制之类的事情。这种都具备一个通用的行为的数据我们可以认为是相似的数据。这给我们另一个提示，我们写下的行为，或者说操作函数，在很多时候是可以用于一大堆种类的数据的。而我们提炼出来的数据间的相似性，很多时候也表明了我们在使用这些数据时我们的关注重心。</t>
          </p>
          <div class="code_block">
            <div class="code_part">
              <div class="code_lang">haskell</div>
              <div class="code_part_text">
                <t>min :: (Ord t) =&gt; t -&gt; t -&gt; t
min a b = case compare a b of
  LT -&gt; a
  GT -&gt; b
  EQ -&gt; a</t>
              </div>
            </div>
            <div class="caption">
              <t>Haskell 语言中取最小值的函数，可以看到我们只限制了 a 和 b 是 Ord 的，也就是可排序的。 </t>
            </div>
          </div>
          <p>
            <t>把相似的数据存储在一起，我们就可以在我们需要的时候只拿取出我们想要的数据，而我们对这些数据执行的操作又是相同的，因为这些数据有共同的特征，这就是数据的模式。</t>
          </p>
          <div class="image_wrapper"><img src="/post/935d27d8-8e8a-4559-8c56-ee8ed6daf2b4/img_20591fe3-30ae-4894-8e08-f3266c1e7548.png">
            <div class="caption"></div>
          </div>
          <p>
            <t>因此，数据驱动的编程范式更适合用于处理对大量相似的数据做同类操作的问题，它们天生就有更好的性能，并且能够更方便地使用多线程相关的优化技巧。但并不适合处理对某些特殊数据做某些操作的任务，因为这通常意味着我们得生造出那个特殊数据的“相似性”，并要求其他数据不满足这个特性，而这是反模式的。这种任务天生更适合用面向对象的方法完成。</t>
          </p>
          <h1 id="heading1_6">
            <t>什么是 ECS</t>
          </h1>
          <p>
            <t></t>
            <t> </t>
          </p>
          <blockquote>
            <t>本篇介绍的 Component 与 Unity 的 Component 并不相同，类似地 Entity 也并不是 GameObject，它们或许有些类似，但请大家不要带入过往的经验。</t>
          </blockquote>
          <p>
            <t>ECS 指的是 Entities（实体）| Components（组件）| Systems（系统）模型。实体指一个特殊的单位，它将许多组件打包在一起，组件负责存储数据；而系统则负责处理数据。 </t>
          </p>
          <blockquote>
            <t>ECS 是一种用面向数据思想设计的框架，我们下面也会介绍 ECS 系统如何用面向数据思想来实现的。</t>
          </blockquote>
        </div>
      </div>
    </div>
  </body>
</html>
